Висновки (що я побачила емпірично)
- Для малих N всі три алгоритми можуть давати порівнянні результати; insertion часто виглядає добре.
- Для великих N insertion стає непрактичним.
- Timsort за рахунок вбудованих оптимізацій (детекція вже відсортованих підмасивів — runs, використання insertion для коротких сегментів, і оптимізоване злиття) часто значно швидший за робочу реалізацію merge sort, особливо на реальних даних з частковою упорядкованістю.
- Тому використання вбудованих `sorted()`/`.sort()` у Python майже завжди кращий вибір.

також я додала графік для швидкого розуміння різницю різних типів сортування - sorting_benchmark.png